/**************************************************************************
    @file    wFilter.h
    @version V1.0
    @date    2022.02.25
    滤波器采用二阶Butterworth滤波器
**************************************************************************/
#ifndef __WCOMMONALG_H__
#define __WCOMMONALG_H__

#include "stm32f10x.h"

typedef struct
{
    float fRef; //参考信号
    float fErr; //误差输入
    float fKp; //比例参数
    float fKi; //积分参数
    float fKd; //微分参数
    float fDt;    // PID 步长.
    float fOut;   // PID 计算输出
    float fE_Pre; // 前一个误差
    float fDE;  //微分 
    float fE_Int;   // 累计误差
    float fInt_Lim; // 累计误差限幅
    float fKP_Out; //比例项（比例*误差）
    float fKI_Out;//积分项
    float fKD_Out;//微分项
} CTRL_PID_P;

/**************************************************************************
 * 帧数据处理的字节变换前四个处理发送，后一个处理接收
 **************************************************************************/

#define BYTE0(dwTemp) (*((char *)(&dwTemp)))
#define BYTE1(dwTemp) (*((char *)(&dwTemp) + 1))
#define BYTE2(dwTemp) (*((char *)(&dwTemp) + 2))
#define BYTE3(dwTemp) (*((char *)(&dwTemp) + 3))
#define BYTETOWORD(x, y) ((s16)(x << 8) | y)
/**************************************************************************
限幅函数，当Data绝对值大于deadband时为0
**************************************************************************/
#define LIMIT(x, min, max) ((x) < (min) ? (min) : ((x) > (max) ? (max) : (x)))

/**************************************************************************
 * 	Function: 二阶Butterworth滤波器参数求解,输入采样频率及截止频率,输出长度为5的一维数组
 **************************************************************************/
void vBut_LPF_Par_Set(float fF_Par, float fSam_F, float *fCut_F);

/**************************************************************************
 * 	Function: 二阶Butterworth滤波器输出,输入为fIn(t),fIn(t-1),fIn(t-2),滤波器参数fF_Par
 * 数组长度uDim，输出为fOut
 **************************************************************************/
void vBut_LPF_O(float *fOut, float *fIn, float *fIn_D1, float *fIn_D2, float *fF_Par, uint8_t uDim);


/**************************************************************************
 * 	Function: 一阶低通滤波器参数求解,输入采样频率及截止频率,输出长度为uDim数组
 **************************************************************************/
void vLPF_First_Par_Set(float *fF_Par, float *fCut_F, float fSam_F, uint8_t uDim);


/**************************************************************************
 * 	Function: 一阶低通滤波器输出,输入为fIn,滤波器参数fF_Par(0-1),输出为fOut
 **************************************************************************/
void vBut_LPF_First(float *fOut, float *fIn, float *fF_Par, uint8_t uDim);

/**************************************************************************
 * 	Function: PID算法，输入为结构体格式的pid参数及当前的误差
 * 输出为fOut存入pid结构体对应位置
 **************************************************************************/
void vPID_Control(CTRL_PID_P *Pid, float fErr);

/******************************************
 * 重置pid的输出
 ******************************************/
void vPid_Par_Reset(CTRL_PID_P *pid);

/******************************************
 * pid参考信号设置
 ******************************************/
void vPid_Ref_Set(float *fRef, float fData);

/**************************************************************************
    平分根求逆的快速计算
**************************************************************************/
float fCal_Inv_Sqrt(float fTem);

/**************************************************************************
 * 	FIFO 队列，末尾为新存入数据fData
 **************************************************************************/
void vFIFO_Queuf(float *fBuff, float fData, uint16_t uDim);
void vFIFO_Queui(uint32_t *iBuff, int32_t iData, uint16_t uDim);

/**************************************************************************
 * 	返回平均值
 **************************************************************************/
float fAve_Get(float *fBuff, uint16_t uDim);
uint32_t uAve_Get(uint32_t *uBuff, uint16_t uDim);
uint8_t uCheck_FIFO(float *fBuff, uint16_t uDim);
/**************************************************************************
 * 	求两个数组的差结果存在fout，uDimw为数组长度
 **************************************************************************/
void vData_Bias_Movf(float *fOut, float *fIn, uint8_t uDim);
void vData_Bias_Movi(int32_t *iOut, int32_t *iIn, uint8_t uDim);

/**************************************************************************
    大数定律求统计平均，输入新的值fIn,输出fOut，步长fDt,维数uDim，
**************************************************************************/
void vLarge_Num_F(float *fOut, float *fIn, float fDt, uint8_t uDim);


/**************************************************************************
    求两个数组的和结果存在fout
**************************************************************************/
void vSum_Two_Num(float *fOut, float *fIn, uint8_t uDim);

/**************************************************************************
    数组除以一个数后保存数组
**************************************************************************/
void vDiv_Two_Num(float *fOut, float fIn, uint8_t uDim);

/**************************************************************************
标量死区函数，当Data绝对值小于deadband时为0，其他值时Data+-deadband
**************************************************************************/
float fDeadband_S(float fData, float fDeadb);
/**************************************************************************
向量死区函数，当Data绝对值小于deadband时为0，其他值时Data-deadband
**************************************************************************/
void vDeadband_V(float *fData, float *fDeadb, uint8_t uDim);
/**************************************************************************
    16int转成float型，输入为16位int,偏置量，限幅及变换尺度，返回为float型
************************************************************************/
float fInt_To_Float(s16 sData, u8 uLim, u16 uBias, u16 uRange, float fScale);

/************************************************************************************************
    Buf中无符号字节数组转成16Int型数组，输入为16位int型数组地址,字节数组地址，字节地址偏置及int数组长度
**********************************************************************************************/
void vBuf_BtoI(s16 *sOut, u8 *uIn, u8 uBias, u8 uLen);

/************************************************************************************************
    批量复位
**********************************************************************************************/
void vVector_Par_Reset(float *fIn,  u8 uLen);


/************************************************************************************************
    输出限幅，输入sL,sH为门限
**********************************************************************************************/
s16 sThreshold(s16  sIn, s16 sL, s16 sH);

float fThreshold(float  fIn, float fL, float fH);

#endif
